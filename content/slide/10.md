+++
contentType = "md"
weight = 10
+++

---
class: center, middle, inverse

# Lembrete importante
## O computador faz o que você manda, não o que você quer.
---
layout: false
.left-column[
  ## O que é a shell?
]
.right-column[
  _Shell_ é um nome comumente dado ao interpretador de comandos num sistema operacional.

  ## Por que aprender a usar?

  A grande maioria das pessoas usando Linux diariamente vai usar o shell em
  algum momento. O shell mais comum no Linux é o bash (_Bourne Again Shell_),
  baseado no original _Bourne Shell_ do Unix, com várias melhorias.

  ## Mas o shell não é só para comandos?

  Não necessariamente. O bash possui uma linguagem de programação bastante completa
  e várias possibilidades de configuração que tornam o trabalho diário mais
  rápido e eficiente.

  Nesses slides, o foco será mostrar como configurar o seu ambiente tornando a vida
  mais fácil e produtiva.
]
---
.left-column[
  ## Arquivos de configuração
]
.right-column[
- Grande parte dos comandos de configuração pode ser digitada diretamente na _prompt_ do
sistema (por default, `$`).

- Observe que configurações feitas dessa maneira **não sobrevivem ao final da
  sessão** e teriam que ser refeitas em cada janela. Isso obviamente não seria muito útil.

- Para tornar as configurações permanentes, edite o arquivo `~/.bashrc` (um dos arquivos de
  inicialização do bash) e insira os comandos naquele arquivo (normalmente, no final).

- Este arquivo é automaticamente executado pelo bash no início de cada sessão "não login".

- Qualquer editor pode ser usado. Para iniciantes, o `nano` um a boa opção.
]
---
.left-column[
  ## VISUAL & EDITOR
]
.right-column[
Vários comandos abrem um editor por default. Para especificar o editor a ser
usado, use as variáveis de ambiente `VISUAL` e `EDITOR`.

Em alguns casos, `VISUAL` é o primeiro a ser tentado, e em caso de falha,
`EDITOR` é tentado. Recomendação: Configure as duas variáveis apontando para o
seu editor preferido

Como:

Edite o arquivo `~/.bashrc` e adicione as seguintes linhas:

```
export EDITOR="nano"
export VISUAL="nano"
```

Para verificar, abra outro terminal e digite `echo $VISUAL`. A string `nano` deverá ser
mostrada.
]
---
class: center, middle, inverse

# Command History
## (Histórico de comandos)
---
.left-column[
  ## Command history
  ### (histórico de comandos)
]
.right-column[
Todos (ou quase todos) os comandos digitados são guardados no arquivo
`~/.bash_history` automaticamente.

Quando digitamos seta-para-cima para recuperar o comando anterior, o bash está
retornando comandos armazenados no histórico de comandos.

É também possível usar o comando `history` para visualizar o que está guardado no history até o momento:

Ex:

```text
$ history
1  nano ~/.bashrc
2  echo $VISUAL
3  ls -l
```

Dica: É possível executar um comando diretamente do prompt pelo número. Digite `!n` onde `n` é o numero do comando no history. Ex:

```bash
$ !2
```

Executaria `echo $VISUAL` novamente.

]
---
.left-column[
  ## Busca no histórico
]
.right-column[
### A maneira mais óbvia

Usar `history` e filtrar apenas o que se deseja usando `grep`:
```bash
$ history | grep "cd"
1  cd /tmp
5  cd
6  cd /home/meh/github/abc
9  vi cdcase.txt
```

E então usar o comando `!n` para executar o comando desejado.

### Uma maneira melhor
* Digite `Ctrl-R` (ativa a função de busca interativa reversa no histórico)
* Digite parte do comando a buscar.
* `Ctrl-R` novamente busca a próxima ocorrência.
* Para executar o comando mostrado, digite `Enter`.
]
---
.left-column[
  ## Um histórico melhor.
]
.right-column[
Na configuração default, o histórico é relativamente pequeno (500 entradas). Para aumentar o tamanho do histórico,
adicione as seguintes linhas do seu `~/.bashrc`:

```
export HISTFILESIZE=100000
export HISTSIZE=$HISTFILESIZE
```

Isso aumentará o tamanho do histórico no disco e em memória para 100.000 entradas.

É também possível adicionar _timestamps_ ao histórico. Com isso, o comando
`history` passa a exibir a data e hora que um determinado comando foi
executado. Adicione ao seu `~/.bashrc`:

```
export HISTTIMEFORMAT='+%Y-%m-%d %H:%M:%S: '
```

Abra um novo terminal e experimente usar o comando `history` novamente.

]

---
.left-column[
  ## Markdown extensions
  ### - Slide properties
]
.right-column[
Initial lines containing key-value pairs are extracted as slide properties:

```remark
name: agenda
class: middle, center

# Agenda

The name of this slide is {{ name }}.
```

Slide properties serve multiple purposes:

* Naming and styling slides using properties `name` and `class`

* Using slides as templates using properties `template` and `layout`

* Expansion of `{{ property }}` expressions to property values

See the [complete list](https://github.com/gnab/remark/wiki/Markdown#slide-properties) of slide properties.
]
---
.left-column[
  ## Markdown extensions
  ### - Slide properties
  ### - Content classes
]
.right-column[
Any occurences of one or more dotted CSS class names followed by square brackets are replaced with the contents of the brackets with the specified classes applied:

```remark
.footnote[.red.bold[*] Important footnote]
```

Resulting HTML extract:

```xml
<span class="footnote">
  <span class="red bold">*</span> Important footnote
</span>
```
]
---
.left-column[
  ## Markdown extensions
  ### - Slide properties
  ### - Content classes
  ### - Syntax Highlighting
]
.right-column[
Code blocks can be syntax highlighted by specifying a language from the set of [supported languages](https://github.com/gnab/remark/wiki/Configuration#highlighting).

Using [GFM](http://github.github.com/github-flavored-markdown/) fenced code blocks you can easily specify highlighting language:

.pull-left[

<pre><code>```javascript
function add(a, b)
  return a + b
end
```</code></pre>
]
.pull-right[

<pre><code>```ruby
def add(a, b)
  a + b
end
```</code></pre>
]

A number of highlighting [styles](https://github.com/gnab/remark/wiki/Configuration#highlighting) are available, including several well-known themes from different editors and IDEs.

]
---
.left-column[
  ## Presenter mode
]
.right-column[
To help out with giving presentations, a presenter mode comprising the
following features is provided:

- Display of slide notes for the current slide, to help you remember
  key points

- Display of upcoming slide, to let you know what's coming

- Cloning of slideshow for viewing on extended display
]
---
.left-column[
  ## Presenter mode
  ### - Inline notes
]
.right-column[
Just like three dashes separate slides,
three question marks separate slide content from slide notes:

```
Slide 1 content

*???

Slide 1 notes

---

Slide 2 content

*???

Slide 2 notes
```

Slide notes are also treated as Markdown, and will be converted in the
same manner slide content is.

Pressing __P__ will toggle presenter mode.
]
???
Congratulations, you just toggled presenter mode!

Now press __P__ to toggle it back off.
---
.left-column[
  ## Presenter mode
  ### - Inline notes
  ### - Cloned view
]
.right-column[
Presenter mode of course makes no sense to the audience.

Creating a cloned view of your slideshow lets you:

- Move the cloned view to the extended display visible to the audience

- Put the original slideshow in presenter mode

- Navigate as usual, and the cloned view will automatically keep up with the original

Pressing __C__ will open a cloned view of the current slideshow in a new
browser window.
]
---
class: center, middle, inverse

## It's time to get started!
---
.left-column[
  ## Getting started
]
.right-column[
Getting up and running is done in only a few steps:

1. Visit the [project site](http://github.com/gnab/remark)

2. Follow the steps in the Getting Started section

For more information on using remark, please check out the [wiki](https://github.com/gnab/remark/wiki) pages.
]
---
class: center, middle, inverse

## That's all folks (for now)!

Slideshow created using [remark](http://github.com/gnab/remark).

