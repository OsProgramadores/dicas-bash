+++
contentType = "md"
weight = 10
+++

---
layout: false
.left-column[
  ## O que é a shell?
]
.right-column[
  _Shell_ é um nome comumente dado ao interpretador de comandos num sistema operacional.

  ## Por que aprender a usar?

  A grande maioria das pessoas usando Linux diariamente vai usar o shell em
  algum momento. O shell mais comum no Linux é o bash (_Bourne Again Shell_),
  baseado no original _Bourne Shell_ do Unix, com várias melhorias.

  ## Mas o shell não é só para comandos?

  Não necessariamente. O bash possui uma linguagem de programação bastante completa
  e várias possibilidades de configuração que tornam o trabalho diário mais
  rápido e eficiente.

  Nesses slides, o foco será mostrar como configurar o seu ambiente tornando a vida
  mais fácil e produtiva.
]
---
.left-column[
  ## Arquivos de configuração
]
.right-column[
- Grande parte dos comandos de configuração pode ser digitada diretamente na _prompt_ do
sistema (por default, `$`).

- Observe que configurações feitas dessa maneira **não sobrevivem ao final da
  sessão** e teriam que ser refeitas em cada janela. Isso obviamente não seria
  muito útil.

- Para tornar as configurações permanentes, edite o arquivo `~/.bashrc` (um dos
  arquivos de inicialização do bash) e insira os comandos naquele arquivo
  (normalmente, no final).

- Este arquivo é automaticamente executado pelo bash no início de cada sessão
  "não login".

- Qualquer editor pode ser usado. Para iniciantes, o `nano` é uma opção simples
  e fácil.
]
---
.left-column[
  ## VISUAL & EDITOR
]
.right-column[
Vários comandos abrem um editor por default. Para especificar o editor a ser
usado, use as variáveis de ambiente `VISUAL` e `EDITOR`.

Em alguns casos, `VISUAL` é o primeiro a ser tentado, e em caso de falha,
`EDITOR` é tentado. Recomendação: Configure as duas variáveis apontando para o
seu editor preferido

Como:

Edite o arquivo `~/.bashrc` e adicione as seguintes linhas:

```
export EDITOR="nano"
export VISUAL="nano"
```

Para verificar, abra outro terminal e digite `echo $VISUAL`. A string `nano` deverá ser
mostrada.
]
---
class: center, middle, inverse

# Command History
## (Histórico de comandos)
---
.left-column[
  ## Histórico de comandos
]
.right-column[
Todos (ou quase todos) os comandos digitados são guardados no arquivo
`~/.bash_history` automaticamente.

Quando digitamos seta-para-cima para recuperar o comando anterior, o bash está
retornando comandos armazenados no histórico de comandos.

É também possível usar o comando `history` para visualizar o que está guardado
no history até o momento:

Ex:

```text
$ history
1  nano ~/.bashrc
2  echo $VISUAL
3  ls -l
```

Dica: É possível executar um comando diretamente do prompt pelo número. Digite
`!n` onde `n` é o numero do comando no history. Ex:

```bash
$ !2
```

Executaria `echo $VISUAL` novamente.

]
---
.left-column[
  ## Histórico de comandos
  ### Buscando comandos
]
.right-column[
### A maneira mais óbvia

Usar `history` e filtrar apenas o que se deseja usando `grep`:
```bash
$ history | grep "cd"
1  cd /tmp
5  cd
6  cd /home/meh/github/abc
9  vi cdcase.txt
```

E então usar o comando `!n` para executar o comando desejado.

### Uma maneira melhor
* Digite `Ctrl-R` (ativa a função de busca interativa reversa no histórico)
* Digite parte do comando a buscar.
* `Ctrl-R` novamente busca a próxima ocorrência.
* Para executar o comando mostrado, digite `Enter`.
]
---
.left-column[
  ## Histórico de comandos
  ### Buscando comandos
  ### Aumentando o histórico
]
.right-column[
Na configuração default, o histórico é relativamente pequeno (500 entradas). Para aumentar o tamanho do histórico,
adicione as seguintes linhas do seu `~/.bashrc`:

```
export HISTFILESIZE=100000
export HISTSIZE=$HISTFILESIZE
```

Isso aumentará o tamanho do histórico no disco e em memória para 100.000 entradas.

É também possível adicionar _timestamps_ ao histórico. Com isso, o comando
`history` passa a exibir a data e hora que um determinado comando foi
executado. Adicione ao seu `~/.bashrc`:

```
export HISTTIMEFORMAT='+%Y-%m-%d %H:%M:%S: '
```

Abra um novo terminal e experimente usar o comando `history` novamente.

]

---
.left-column[
  ## Histórico de comandos
  ### Buscando comandos
  ### Aumentando o histórico
  ### Compartilhando o histórico
]
.right-column[
O histórico em memória só é salvo automaticamente no final de cada
sessão (quando o terminal é fechado). Com isso, os comandos de uma sessão só
ficam disponíveis para outras sessões quando a sessão se encerra (ex: `Ctrl-D`,
`exit`, etc).

Dica: Crie um _alias_ (chamado `hr`) que adiciona o histórico da sessão corrente
ao histórico em disco, recarregando em seguida o histórico de todas as sessões.

Edite o seu `~/.bashrc` e adicione:

```bash
alias hr='history -a; history -c; history -r'
```

Digite `hr` em cada sessão que onde precise compartilhar ou ler um histórico
compartilhado imediatamente.  O histórico continuará sendo salvo ao final da
sessão, normalmente.
]

---
class: center, middle, inverse

# Digitando menos
## (e fazendo mais)
---

.left-column[
  ## Digitando menos
  ### Usando as setas
]
.right-column[
Para rever os comandos anteriores no histórico, use `seta-para-cima` (ou
`Ctrl-P`). É possível navegar pelo histórico com `seta-pra-baixo` (ou `Ctrl-N`)
nesse modo.

Para achar um comando no histórico, use `Ctrl-R` (conforme mencionado anteriormente).

## Simplificando a busca

Adicione
os comandos abaixo ao arquivo `~/.inputrc` (atenção, não `~/.bashrc`! Crie o arquivo se
não existir):

<code class="javascript hjls remark-code">
"\e&#91;A": history-search-backward<br>
"\e&#91;B": history-search-forward
</code>

Com essa configuração, é possível iniciar um comando e usar `seta-para-cima` e
apenas os comandos no histórico começando com o string já digitado serão
mostrados.
]

---
.left-column[
  ## Digitando menos
  ### Usando as setas
  ### Designadores de eventos
]
.right-column[
O bash reconhece uma série de _Event Designators_, que são referências a um
comando digitado anteriormente. Existem diversos designadores e diversos
"modificadores". Os de uso mais comum:

* `!n` Expande para o comando número _n_ no histórico (ex: `!5`).

* `!!` Expande para o último comando digitado. Uso comum: Depois do comando
  digitado, descobre-se que é preciso rodar o comando com `sudo`. Neste caso,
  basta usar `sudo !!` para repetir o comando. Pode ser usado diretamente para
  repetir o último comando.

* `!string` Expande para o comando mais recente iniciando pelo string desejado.
  Ex: para repetir a última linha de compilação usando o gcc (supondo que uma
  exista no seu histórico): `!gcc`

]

---
.left-column[
  ## Digitando menos
  ### Usando as setas
  ### Designadores de eventos
  ### Mais designadores
]
.right-column[
* `^str1^str2^` Troca o string `str1` por `str2` no último comando a
  re-executa. Ex: Um comando foi digitado incorretamente: `ls /tmp/foo`, mas o
  correto seria `ls /tmp/bar`. Nesse caso, basta digitar `^foo^bar^`

Existem também designadores de palavras que permitem que certas palavras dentro
de um comando sejam extraídas, e "modificadores", que modificam o comportamento
das expansões. Exemplos práticos:

* `!!:$` Expande para a última palavra no comando anterior. Ex: Logo apos usar
  `cat arquivoX` pode-se usar `cp !!:$ /tmp` para copiar o `arquivoX` (última
  palavra do comando anterior) para `/tmp`.

A lista de possibilidades é grande. Consulte o _man page_ do bash (`man bash`)
e procure por _Event Designators_ para maiores detalhes.  ]

---
.left-column[
  ## Digitando menos
  ### Usando as setas
  ### Designadores de eventos
  ### Mais designadores
  ### Tab completion
]
.right-column[
A tecla `Tab` completa o arquivo começando com o string já digitado.  Exemplo:
`md5sum photos_1<tab>` vai listar todos os arquivos no diretório corrente
começando com `photos_1`.

### Melhorias

Edite o seu arquivo `~\.inputrc` e adicione as seguintes linhas:

```
set show-all-if-ambiguous on
set completion-ignore-case On
set colored-completion-prefix on
```

Isso causa a tecla `Tab` mostrar todos os casos que podem ser completados,
ignorar maíusculas e minúsculas nos arquivos e mostrar o prefixo já digitado
com cores diferentes.

Nota: O bash possui um sistema complexo chamado _Programmable Completion_ que
adiciona inteligência à tecla Tab. Consulte a _man page_ do bash (`man bash`)
para maiores detalhes.

]

---
.left-column[
  ## Digitando menos
  ### Usando as setas
  ### Designadores de eventos
  ### Mais designadores
  ### Tab completion
  ### Outras pérolas
]
.right-column[
* Comando ficando muito complicado para editar na linha de comando? Digite
  `Ctrl-X` `Ctrl-E` e o bash abrirá o comando atual no editor de textos
  especificado na variável `$VISUAL`. O comando será executado ao sair do
  editor.

* No meio da digitação de um comando longo que quer salvar, mas não quer
  executar agora? Digite `<ESC>#` a qualquer ponto e o bash adicionará um
  caracter de comentário (`#`) na frente do comando e o salvará no histórico
  para uso posterior.

* Precisa de ajuda rápida em um comando interno mas não tem tempo de ler o _man page_
  inteiro? Use o comando `help`. Exemplo: `help history`.

* Precisa voltar para o diretório anterior mas não quer digitar o nome
  completo? Basta usar o comando `cd -` para mudar o diretório para o último
  diretório visitado.

]
